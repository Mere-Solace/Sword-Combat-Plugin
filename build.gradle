plugins {
    id 'java'
    id 'checkstyle'
    id 'pmd'
    id 'com.diffplug.spotless' version '6.25.0'
    id 'xyz.jpenilla.run-paper' version '2.3.1'
}

// Project metadata from gradle.properties
group = project.property('group')
version = project.property('version')

repositories {
    mavenCentral()
    maven {
        name = "papermc-repo"
        url = "https://repo.papermc.io/repository/maven-public/"
    }
    maven {
        name = "sonatype"
        url = "https://oss.sonatype.org/content/groups/public/"
    }
    maven {
        name = "dmulloy2-repo"
        url = uri("https://repo.dmulloy2.net/repository/public/")
    }
    maven {
        name "xenondevsReleases"
        url 'https://repo.xenondevs.xyz/releases'
    }
}

dependencies {
    compileOnly("io.papermc.paper:paper-api:1.21-R0.1-SNAPSHOT")
    implementation 'com.google.code.gson:gson:2.10.1'
    implementation "xyz.xenondevs.invui:invui:1.0"
//    compileOnly "com.comphenix.protocol:ProtocolLib:5.1.0"

    compileOnly 'org.projectlombok:lombok:1.18.34'
    annotationProcessor 'org.projectlombok:lombok:1.18.34'

    // Testing dependencies
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.1'
    testImplementation 'org.mockito:mockito-core:5.7.0'
    testImplementation 'org.mockito:mockito-junit-jupiter:5.7.0'
    testImplementation 'com.github.seeseemelk:MockBukkit-v1.20:3.9.0'
    testImplementation("io.papermc.paper:paper-api:1.21-R0.1-SNAPSHOT")

    // Force newer version of commons-lang3 to address CVE-2025-48924
    constraints {
        testImplementation('org.apache.commons:commons-lang3:3.17.0') {
            because 'CVE-2025-48924: Vulnerability in commons-lang3:3.12.0'
        }
    }
}

tasks {
    runServer {
        // Configure the Minecraft version for our task.
        // This is the only required configuration besides applying the plugin.
        // Your plugin's jar (or shadowJar if present) will be used automatically.
        minecraftVersion("1.21.8")
    }
}

// Configure test task to use JUnit Platform
test {
    useJUnitPlatform()
    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat "full"
        showStandardStreams = false
    }
}

def targetJavaVersion = 21
java {
    def javaVersion = JavaVersion.toVersion(targetJavaVersion)
    sourceCompatibility = javaVersion
    targetCompatibility = javaVersion
    if (JavaVersion.current() < javaVersion) {
        toolchain.languageVersion = JavaLanguageVersion.of(targetJavaVersion)
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'

    if (targetJavaVersion >= 10 || JavaVersion.current().isJava10Compatible()) {
        options.release.set(targetJavaVersion)
    }
}

processResources {
    def props = [version: version]
    inputs.properties props
    filteringCharset 'UTF-8'
    filesMatching('paper-plugin.yml') {
        expand props
    }
}

// Checkstyle configuration - detects code quality issues
checkstyle {
    toolVersion = '10.12.5'
    configFile = file("${rootDir}/config/checkstyle/checkstyle.xml")
    ignoreFailures = true  // Warning mode - don't fail builds initially
    showViolations = true
}

tasks.withType(Checkstyle).configureEach {
    reports {
        xml.required = true
        html.required = true
    }
}

// PMD configuration - detects code quality issues (unused variables, dead code, etc.)
pmd {
    toolVersion = '7.0.0'
    consoleOutput = true
    ignoreFailures = true  // Informational only - never blocks builds
    ruleSets = []  // Clear default rules
    ruleSetFiles = files("${rootDir}/config/pmd/pmd-rules.xml")
}

tasks.withType(Pmd).configureEach {
    reports {
        xml.required = true
        html.required = true
    }
}

// Spotless configuration - auto-fixes code formatting
spotless {
    java {
        target 'src/**/*.java'

        // Remove unused imports
        removeUnusedImports()

        // Format imports
        importOrder()

        // Apply formatting
        indentWithSpaces(4)
        trimTrailingWhitespace()
        endWithNewline()

        // Optional: Use Google Java Format or Palantir
        // googleJavaFormat()
    }

    // Markdown formatting
    format 'markdown', {
        target '**/*.md'
        targetExclude 'build/**', '.gradle/**', 'gradlew.bat'

        // Prettier for markdown formatting
        prettier(['prettier': '2.8.8', 'prettier-plugin-sh': '0.12.8'])
            .config([
                'parser': 'markdown',
                'printWidth': 100,
                'proseWrap': 'always',
                'tabWidth': 2
            ])
    }
}

// Javadoc coverage analysis task
tasks.register('javadocCoverage') {
    description = 'Generates a report showing Javadoc documentation coverage'
    group = 'documentation'

    doLast {
        def srcDir = file('src/main/java')
        def reportFile = file('docs/reports/javadoc-coverage-baseline.md')
        reportFile.parentFile.mkdirs()

        def stats = [
            totalClasses: 0,
            documentedClasses: 0,
            totalMethods: 0,
            documentedMethods: 0,
            classDetails: []
        ]

        // Analyze all Java files
        fileTree(srcDir).matching { include '**/*.java' }.each { file ->
            def content = file.text
            def fileName = file.name
            def relativePath = srcDir.toPath().relativize(file.toPath()).toString()

            // Count classes/interfaces
            def classMatches = (content =~ /(?m)^\s*public\s+(class|interface|enum)\s+\w+/)
            if (classMatches.size() > 0) {
                stats.totalClasses++

                // Check if class has Javadoc (/** */ before class declaration)
                def hasClassJavadoc = content =~ /\/\*\*[\s\S]*?\*\/\s*(public\s+)?(class|interface|enum)/
                def classDocumented = hasClassJavadoc.size() > 0
                if (classDocumented) stats.documentedClasses++

                // Count public methods (including static, final, synchronized, abstract)
                def methodMatches = (content =~ /(?m)^\s*public\s+(?:static\s+|final\s+|synchronized\s+|abstract\s+)*(?!class|interface|enum)\S+\s+\w+\s*\(/)
                def totalMethodsInClass = methodMatches.size()

                // Count documented methods (/** */ before public method, accounting for modifiers)
                def docMethodMatches = (content =~ /\/\*\*[\s\S]*?\*\/\s*public\s+(?:static\s+|final\s+|synchronized\s+|abstract\s+)*(?!class|interface|enum)\S+\s+\w+\s*\(/)
                def documentedMethodsInClass = docMethodMatches.size()

                stats.totalMethods += totalMethodsInClass
                stats.documentedMethods += documentedMethodsInClass

                // Calculate coverage for this class
                def methodCoverage = totalMethodsInClass > 0 ?
                    (documentedMethodsInClass * 100.0 / totalMethodsInClass) : 100.0

                stats.classDetails << [
                    name: fileName,
                    path: relativePath,
                    hasClassDoc: classDocumented,
                    totalMethods: totalMethodsInClass,
                    documentedMethods: documentedMethodsInClass,
                    coverage: methodCoverage
                ]
            }
        }

        // Sort by coverage (worst first)
        stats.classDetails.sort { it.coverage }

        // Generate report
        def report = new StringBuilder()
        report << "# Javadoc Coverage Baseline Report\n\n"
        report << "**Generated:** ${new Date().format('yyyy-MM-dd HH:mm:ss')}\n\n"
        report << "## Summary\n\n"

        def classPercent = stats.totalClasses > 0 ?
            String.format("%.1f", stats.documentedClasses * 100.0 / stats.totalClasses) : "0.0"
        def methodPercent = stats.totalMethods > 0 ?
            String.format("%.1f", stats.documentedMethods * 100.0 / stats.totalMethods) : "0.0"

        report << "| Metric | Count | Percentage |\n"
        report << "|--------|-------|------------|\n"
        report << "| **Total Classes** | ${stats.totalClasses} | - |\n"
        report << "| **Documented Classes** | ${stats.documentedClasses} | ${classPercent}% |\n"
        report << "| **Total Public Methods** | ${stats.totalMethods} | - |\n"
        report << "| **Documented Methods** | ${stats.documentedMethods} | ${methodPercent}% |\n\n"

        report << "## Classes Needing Documentation (Sorted by Priority)\n\n"
        report << "| Class | Path | Class Doc | Methods | Documented | Coverage |\n"
        report << "|-------|------|-----------|---------|------------|----------|\n"

        stats.classDetails.take(20).each { cls ->
            def classDoc = cls.hasClassDoc ? "✓" : "✗"
            def coverage = String.format("%.0f%%", cls.coverage)
            report << "| ${cls.name} | ${cls.path} | ${classDoc} | ${cls.totalMethods} | ${cls.documentedMethods} | ${coverage} |\n"
        }

        if (stats.classDetails.size() > 20) {
            report << "\n*... and ${stats.classDetails.size() - 20} more classes*\n"
        }

        report << "\n## Well-Documented Classes (100% Coverage)\n\n"
        def wellDocumented = stats.classDetails.findAll { it.coverage == 100.0 && it.hasClassDoc }
        if (wellDocumented.isEmpty()) {
            report << "*No classes with 100% documentation coverage yet.*\n"
        } else {
            report << "| Class | Path | Methods Documented |\n"
            report << "|-------|------|--------------------|\n"
            wellDocumented.each { cls ->
                report << "| ${cls.name} | ${cls.path} | ${cls.documentedMethods} |\n"
            }
        }

        report << "\n## Recommendations\n\n"
        report << "1. **Start with high-priority classes**: Focus on classes with most methods and 0% coverage\n"
        report << "2. **Target classes without class-level Javadoc**: Add class documentation first\n"
        report << "3. **Document public APIs**: All public methods should have Javadoc\n"
        report << "4. **Track progress**: Re-run this task periodically to measure improvement\n\n"
        report << "## How to Improve\n\n"
        report << "Run: `./gradlew javadocCoverage` to regenerate this report\n\n"
        report << "See [docs/standards/documentation-standards.md](../standards/documentation-standards.md) for Javadoc guidelines.\n"

        reportFile.text = report.toString()

        println "\n========================================="
        println "Javadoc Coverage Report Generated"
        println "========================================="
        println "Total Classes: ${stats.totalClasses}"
        println "Documented Classes: ${stats.documentedClasses} (${classPercent}%)"
        println "Total Public Methods: ${stats.totalMethods}"
        println "Documented Methods: ${stats.documentedMethods} (${methodPercent}%)"
        println "\nReport saved to: ${reportFile.path}"
        println "=========================================\n"
    }
}
